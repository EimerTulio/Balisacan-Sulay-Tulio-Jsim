*******************************************************************************

* LAB #6
* - Balisacan, Lucas Matthew 
* - Sulay, Lucia Danielle
* - Tulio, Eimer Justin

*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************

* First, we plug-in our full adder and 32-bit ripple-carry adder subcircuits.

*******************************************************************************

.subckt fa a b c_in sum c_out
    Xxor1 a b XOR_1 xor2
	Xxor2 XOR_1 c_in Sum xor2
	Xnand1 a b NAND_1 nand2
	Xnand2 XOR_1 c_in NAND_2 nand2
	Xnand3 NAND_1 NAND_2 c_out nand2
.ends

.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
    Xadd[31:0] a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends

*******************************************************************************

* Next, we plug-in our as32 and cmp32 subcircuits.

* To optimize for size, we changed the circuits a bit:

* For the 32-bit adder/subtractor,
* we took the truth table of putting b through an inverter
* then choosing the inverted output only if subtraction is enabled.
* We discovered that the truth table is equivalent to an XOR gate,
* bringing the overall gate count down by 32 gates.

* In stdcell.jsim, a 4-way mux is implemented using 3 2-way muxs.
* So for the 32-bit comparator,
* since we only need 3 conditions (1 is don't-care)
* we turned the 4-way mux into a 3-way mux using 2 2-way muxs,
* bringing the overall gate count down by 1 gate.

*******************************************************************************

.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z

    * for subtractor:
    Xneg[31:0] b[31:0] op0#32 b_out[31:0] xor2
    Xadd a[31:0] b_out[31:0] op0 fas[31:0] cout[31:30] add32

    * for n:
    .connect fas31 n

    * for v:
    X_xor cout[31:30] v xor2

    * for z:
    X_or1[7:0] fas[31:0] x_or1_out[7:0] or4
    X_or2[1:0] x_or1_out[7:0] x_or2_out[1:0] or4
    Xnor x_or2_out[1:0] z nor2

    * using only NANDs/NORs for z:
    * X_nor1[7:0] fas[31:0] x_nor1_out[7:0] nor4
    * X_nand[1:0] x_nor1_out[7:0] x_nand_out[1:0] nand4
    * Xnor2 x_nand_out[1:0] z nor2

.ends

.subckt cmp32 n v z op[2:1] fcmp[31:0]

    * for A < B:
    X_lt n v lt_output xor2

    * for A <= B:
    X_lte z lt_output lte_output or2

    * turned mux4 into 3-way mux using 2 mux2s
    Xmux1 op1 lt_output lte_output op1_out mux2
    Xmux2 op2 z op1_out fcmp0 mux2

    .connect 0 fcmp[31:1]

.ends

*******************************************************************************
*********************** PART 1: Bitwise Boolean Circuit ***********************

* For the bitwise boolean circuit, we simply used 32 4-way muxs,
* 1 for each bit,
* with a as s0 and b as s1,
* and op[3:0] as the results of the truth table
* of a specific boolean operation between a and b.

*******************************************************************************

.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
    Xmux_bool[31:0] a[31:0] b[31:0] op0#32 op1#32 op2#32 op3#32 fbool[31:0] mux4
.ends

*******************************************************************************
***************************** PART 2: Bit Shifter *****************************

* For the bit shifter, we first built a chain of 32 2-way muxs
* for a logical right shift.
* Each set of 32 2-way muxs uses the corresponding bit from b as a selector.
* If the corresponding bit is 0,
* it simply outputs the previous number as-is (no shift).
* If the corresponding bit is 1,
* it shifts the number by the designated number of bits
* defined by the position of the bit in b[4:0] (either 16, 8, 4, 2, or 1),
* and adds the pad bit.

* The pad bit is determined by op1,
* since logical right and logical left shifts and the don't-care condition
* all have 0 as the pad bit.
* If op1 is 1, then this signals an arithmetic right shift
* and thus the pad bit is equal to a31, the sign bit.
* This also reduces the overall gate count by 2,
* as we originally used a 4-way mux (3 2-way muxs) but changed it to 1 2-way mux.

* All shifters are made for right shifts,
* but we did not want to make another set of shifters for a left shift.
* This would have added 32 x 5 = 160 more gates to the overall gate count.
* Instead, we realized that we could simply flip the bits
* (e.g. 1000 becomes 0001),
* shift right,
* and flip the bits again.
* This is equivalent to a left shift.

* To do this, we used 2-way muxs
* with op0 as a selector.
* If op0 is 0,
* this indicates a left shift so the bits are flipped before and after shifting.
* If op0 is 1,
* this indicates a right shift so the bits stay as-is before and after shifting.

*******************************************************************************

.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]

    * left or right
    X1lr[31:0] op0#32 a[0:31] a[31:0] out[31:0] mux2
    

    * padding bit
    Xmux_padbit op1 0 a31 z mux2


    * 16 bit-shifter (b4)
    X16mux[31:0] b4#32 out[31:0] z#16 out[31:16] 16_output[31:0] mux2

    * 8 bit-shifter (b3)
    X8mux[31:0] b3#32 16_output[31:0] z#8 16_output[31:8] 8_output[31:0] mux2

    * 4 bit-shifter (b2)
    X4mux[31:0] b2#32 8_output[31:0] z#4 8_output[31:4] 4_output[31:0] mux2

    * 2 bit-shifter (b1)
    X2mux[31:0] b1#32 4_output[31:0] z#2 4_output[31:2] 2_output[31:0] mux2

    * 1 bit-shifter (b0)
    X1mux[31:0] b0#32 2_output[31:0] z 2_output[31:1] 1_output[31:0] mux2


    * left or right
    X2lr[31:0] op0#32 1_output[0:31] 1_output[31:0] fshift[31:0] mux2

.ends

*******************************************************************************
******************************* PART 3: ALU ***********************************

* Lastly, all subcircuits were instantiated in the ALU subcircuit,
* which uses a 4-way mux to select which subcircuit output will be outputted
* as defined by alufn[5:4].
* alufn[3:0] is passed to the appropriate subcircuit's op[3:0],
* where applicable.

*******************************************************************************

.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]

    * instantiate adder/subtractor
    Xas32 a[31:0] b[31:0] alufn0 fas[31:0] n v z as32

    * instantiate comparator (chained with as32)
    Xcmp32 n v z alufn[2:1] fcmp[31:0] cmp32

    * instantiate boolean
    Xbool32 a[31:0] b[31:0] alufn[3:0] fbool[31:0] bool32

    * instantiate shifter
    Xshift32 a[31:0] b[4:0] alufn[1:0] fshift[31:0] shift32


    * main mux4 - defined by alufn[5:4]
    Xmux_alu[31:0] alufn4#32 alufn5#32 fas[31:0] fbool[31:0] fshift[31:0] fcmp[31:0] f[31:0] mux4

.ends

*******************************************************************************

* Finally, we instantiate the ALU subcircuit.

*******************************************************************************

Xalu32 a[31:0] b[31:0] alufn[5:0] f[31:0] alu32

*******************************************************************************

* We then paste the waveforms given to test our alu32.

*******************************************************************************

Wa a[31:0] nrz(0v,5.0v,20ns,0ns,.1ns,.1ns)
+ -1 0x55555555 0xAAAAAAAA 1 -2 -1 -1 0x55555555 0 -1 0x55555555 0
+ -1 0x55555555 0 -1 0x55555555 0 -1 0x55555555 0 1 -1 -1 0x55555555 0xAAAAAAAA -1
+ 0x55555555 0xAAAAAAAA -1 -1 15 0 -1 15 0 -1 15 0


Wb b[31:0] nrz(0v,5.0v,20ns,0ns,.1ns,.1ns)
+ 1 0x55555555 0xAAAAAAAA 1 0 -1 -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0
+ -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0 31 15 0 24 24 31
+ 24 24 31 1 15 -256 1 15 -256 1 15 -256


Wf alufn[5:0] nrz(0v,5.0v,60ns,0ns,.1ns,.1ns)
+ 0 1 24 30 22 26 21 32 33 35 51 53 55

*******************************************************************************

* Finally, we plot the test cases and their results (f[31:0]).
* TOTAL GATE COUNT: 625 GATES

*******************************************************************************

.tran 800ns
.plot a[31:0]
.plot b[31:0]
.plot alufn[5:0]
.plot f[31:0]
