*******************************************************************************

* LAB #6
* - Balisacan, Lucas Matthew 
* - Sulay, Lucia Danielle
* - Tulio, Eimer Justin

*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
*******************************************************************************

* First, we plug-in our full adder and 32-bit ripple-carry adder subcircuits.

.subckt fa a b c_in sum c_out
  Xxor1 a b XOR_1 xor2
	Xxor2 XOR_1 c_in Sum xor2
	Xnand1 a b NAND_1 nand2
	Xnand2 XOR_1 c_in NAND_2 nand2
	Xnand3 NAND_1 NAND_2 c_out nand2
.ends

.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xadd[31:0] a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends


******************* copying as32 and cmp32 from previous lab *******************

.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
    
    * to optimize for size, we took the truth table of putting b through an inverter 
    * then choosing the inverted output only if subtracting is enabled
    * the truth table is equivalent to an xor gate, bringing the count down by 32 gates
    * for subtractor:
    Xsub[31:0] b[31:0] op0#32 b_out[31:0] xor2
    Xadd a[31:0] b_out[31:0] op0 fas[31:0] cout[31:30] add32

    * for n:
    .connect fas31 n

    * for v:
    X_xor cout[31:30] v xor2

    * for z:
    X_or1[7:0] fas[31:0] x_or1_out[7:0] or4
    X_or2[1:0] x_or1_out[7:0] x_or2_out[1:0] or4
    Xnor x_or2_out[1:0] z nor2

    * using only NANDs/NORs for z:
    * X_nor1[7:0] fas[31:0] x_nor1_out[7:0] nor4
    * X_nand[1:0] x_nor1_out[7:0] x_nand_out[1:0] nand4
    * Xnor2 x_nand_out[1:0] z nor2

.ends

.subckt cmp32 n v z op[2:1] fcmp[31:0]

    * for A < B:
    X_lt n v lt_output xor2

    * for A <= B:
    X_lte z lt_output lte_output or2

    * 4-way mux
    Xmux_comp op[2:1] 0 lt_output z lte_output fcmp0 mux4

    .connect 0 fcmp[31:1]

.ends

*******************************************************************************
*******************************************************************************

*********************** PART 1: Bitwise Boolean Circuit ***********************

.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
    Xmux_bool[31:0] a[31:0] b[31:0] op0#32 op1#32 op2#32 op3#32 fbool[31:0] mux4
.ends


*******************************************************************************


***************************** PART 2: Bit Shifter *****************************

.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]

    * left or right
    * If left, the bit is reversed, since all the shifters are meant for right 
    * shifts. The bit is then reversed again later on, after going through all 
    * the shifters This allows us to conserve on the total number of gates by  
    * not having to make another set of shifters for left shifting. 
    X1lr[31:0] op0#32 a[0:31] a[31:0] out[31:0] mux2
    
    * padding bit
    Xmux_padbit op1 0 a31 z mux2

    * 16 bit-shifter (b4)
    X16mux[31:0] b4#32 out[31:0] z#16 out[31:16] 16_output[31:0] mux2

    * 8 bit-shifter (b3)
    X8mux[31:0] b3#32 16_output[31:0] z#8 16_output[31:8] 8_output[31:0] mux2

    * 4 bit-shifter (b2)
    X4mux[31:0] b2#32 8_output[31:0] z#4 8_output[31:4] 4_output[31:0] mux2

    * 2 bit-shifter (b1)
    X2mux[31:0] b1#32 4_output[31:0] z#2 4_output[31:2] 2_output[31:0] mux2

    * 1 bit-shifter (b0)
    X1mux[31:0] b0#32 2_output[31:0] z 2_output[31:1] 1_output[31:0] mux2


    * left or right
    * Again, if it was a left shift, this is where the bit is reveresed again,
    * back to its original form.
    X2lr[31:0] op0#32 1_output[0:31] 1_output[31:0] fshift[31:0] mux2

.ends


********************************************************************

************************** PART 3: ALU *****************************

.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]

    * instantiate adder/subtractor
    Xas32 a[31:0] b[31:0] alufn0 fas[31:0] n v z as32

    * instantiate comparator (chained with as32)
    Xcmp32 n v z alufn[2:1] fcmp[31:0] cmp32

    * instantiate boolean
    Xbool32 a[31:0] b[31:0] alufn[3:0] fbool[31:0] bool32

    * instantiate shifter
    Xshift32 a[31:0] b[4:0] alufn[1:0] fshift[31:0] shift32


    * main mux4 - defined by alufn[5:4]
    Xmux_alu[31:0] alufn4#32 alufn5#32 fas[31:0] fbool[31:0] fshift[31:0] fcmp[31:0] f[31:0] mux4

.ends

********************************************************************

************************** INSTANTIATE *****************************

Xalu32 a[31:0] b[31:0] alufn[5:0] f[31:0] alu32

********************************************************************

**************************** WAVEFORMS *****************************


Wa a[31:0] nrz(0v,5.0v,20ns,0ns,.1ns,.1ns)
+ -1 0x55555555 0xAAAAAAAA 1 -2 -1 -1 0x55555555 0 -1 0x55555555 0
+ -1 0x55555555 0 -1 0x55555555 0 -1 0x55555555 0 1 -1 -1 0x55555555 0xAAAAAAAA -1
+ 0x55555555 0xAAAAAAAA -1 -1 15 0 -1 15 0 -1 15 0


Wb b[31:0] nrz(0v,5.0v,20ns,0ns,.1ns,.1ns)
+ 1 0x55555555 0xAAAAAAAA 1 0 -1 -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0
+ -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0 -1 0xAAAAAAAA 0 31 15 0 24 24 31
+ 24 24 31 1 15 -256 1 15 -256 1 15 -256


Wf alufn[5:0] nrz(0v,5.0v,60ns,0ns,.1ns,.1ns)
+ 0 1 24 30 22 26 21 32 33 35 51 53 55


*******************************************************************************


************************************ PLOTS ************************************

.tran 800ns
.plot a[31:0]
.plot b[31:0]
.plot alufn[5:0]
.plot f[31:0]